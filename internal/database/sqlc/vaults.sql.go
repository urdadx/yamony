// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vaults.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVault = `-- name: CreateVault :one
INSERT INTO vaults (
    user_id,
    name,
    description,
    icon,
    theme,
    is_favorite
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, name, description, icon, theme, is_favorite, created_at, updated_at
`

type CreateVaultParams struct {
	UserID      int32       `json:"user_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Icon        pgtype.Text `json:"icon"`
	Theme       pgtype.Text `json:"theme"`
	IsFavorite  bool        `json:"is_favorite"`
}

func (q *Queries) CreateVault(ctx context.Context, arg CreateVaultParams) (Vault, error) {
	row := q.db.QueryRow(ctx, createVault,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.Theme,
		arg.IsFavorite,
	)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Theme,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVault = `-- name: DeleteVault :exec
DELETE FROM vaults
WHERE id = $1 AND user_id = $2
`

type DeleteVaultParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteVault(ctx context.Context, arg DeleteVaultParams) error {
	_, err := q.db.Exec(ctx, deleteVault, arg.ID, arg.UserID)
	return err
}

const getUserVaults = `-- name: GetUserVaults :many
SELECT 
    v.id, v.user_id, v.name, v.description, v.icon, v.theme, v.is_favorite, v.created_at, v.updated_at,
    COALESCE(COUNT(vi.id), 0)::int AS item_count
FROM vaults v
LEFT JOIN vault_items vi ON v.id = vi.vault_id
WHERE v.user_id = $1
GROUP BY v.id
ORDER BY v.is_favorite DESC, v.updated_at DESC
`

type GetUserVaultsRow struct {
	ID          int32            `json:"id"`
	UserID      int32            `json:"user_id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Icon        pgtype.Text      `json:"icon"`
	Theme       pgtype.Text      `json:"theme"`
	IsFavorite  bool             `json:"is_favorite"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	ItemCount   int32            `json:"item_count"`
}

func (q *Queries) GetUserVaults(ctx context.Context, userID int32) ([]GetUserVaultsRow, error) {
	rows, err := q.db.Query(ctx, getUserVaults, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserVaultsRow{}
	for rows.Next() {
		var i GetUserVaultsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.Theme,
			&i.IsFavorite,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ItemCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVaultByID = `-- name: GetVaultByID :one
SELECT id, user_id, name, description, icon, theme, is_favorite, created_at, updated_at FROM vaults
WHERE id = $1
`

func (q *Queries) GetVaultByID(ctx context.Context, id int32) (Vault, error) {
	row := q.db.QueryRow(ctx, getVaultByID, id)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Theme,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVaultByIDAndUserID = `-- name: GetVaultByIDAndUserID :one
SELECT id, user_id, name, description, icon, theme, is_favorite, created_at, updated_at FROM vaults
WHERE id = $1 AND user_id = $2
`

type GetVaultByIDAndUserIDParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetVaultByIDAndUserID(ctx context.Context, arg GetVaultByIDAndUserIDParams) (Vault, error) {
	row := q.db.QueryRow(ctx, getVaultByIDAndUserID, arg.ID, arg.UserID)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Theme,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const toggleVaultFavorite = `-- name: ToggleVaultFavorite :one
UPDATE vaults
SET 
    is_favorite = NOT is_favorite,
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, name, description, icon, theme, is_favorite, created_at, updated_at
`

type ToggleVaultFavoriteParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) ToggleVaultFavorite(ctx context.Context, arg ToggleVaultFavoriteParams) (Vault, error) {
	row := q.db.QueryRow(ctx, toggleVaultFavorite, arg.ID, arg.UserID)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Theme,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVault = `-- name: UpdateVault :one
UPDATE vaults
SET 
    name = $2,
    description = $3,
    icon = $4,
    theme = $5,
    is_favorite = $6,
    updated_at = NOW()
WHERE id = $1 AND user_id = $7
RETURNING id, user_id, name, description, icon, theme, is_favorite, created_at, updated_at
`

type UpdateVaultParams struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Icon        pgtype.Text `json:"icon"`
	Theme       pgtype.Text `json:"theme"`
	IsFavorite  bool        `json:"is_favorite"`
	UserID      int32       `json:"user_id"`
}

func (q *Queries) UpdateVault(ctx context.Context, arg UpdateVaultParams) (Vault, error) {
	row := q.db.QueryRow(ctx, updateVault,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Icon,
		arg.Theme,
		arg.IsFavorite,
		arg.UserID,
	)
	var i Vault
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Icon,
		&i.Theme,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
