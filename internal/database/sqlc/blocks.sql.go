// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: blocks.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveBlocksByPageID = `-- name: CountActiveBlocksByPageID :one
SELECT COUNT(*) FROM blocks
WHERE page_id = $1 AND is_active = true
`

func (q *Queries) CountActiveBlocksByPageID(ctx context.Context, pageID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveBlocksByPageID, pageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBlocksByPageID = `-- name: CountBlocksByPageID :one
SELECT COUNT(*) FROM blocks
WHERE page_id = $1
`

func (q *Queries) CountBlocksByPageID(ctx context.Context, pageID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countBlocksByPageID, pageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBlock = `-- name: CreateBlock :one
INSERT INTO blocks (
    page_id,
    user_id,
    block_order,
    is_active,
    title,
    description,
    layout,
    block_type,
    variant,
    properties
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, page_id, user_id, block_order, is_active, created_at, updated_at, title, description, layout, block_type, variant, properties
`

type CreateBlockParams struct {
	PageID      int32       `json:"page_id"`
	UserID      int32       `json:"user_id"`
	BlockOrder  pgtype.Int4 `json:"block_order"`
	IsActive    bool        `json:"is_active"`
	Title       pgtype.Text `json:"title"`
	Description pgtype.Text `json:"description"`
	Layout      string      `json:"layout"`
	BlockType   pgtype.Text `json:"block_type"`
	Variant     pgtype.Text `json:"variant"`
	Properties  []byte      `json:"properties"`
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) (Block, error) {
	row := q.db.QueryRow(ctx, createBlock,
		arg.PageID,
		arg.UserID,
		arg.BlockOrder,
		arg.IsActive,
		arg.Title,
		arg.Description,
		arg.Layout,
		arg.BlockType,
		arg.Variant,
		arg.Properties,
	)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.UserID,
		&i.BlockOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Description,
		&i.Layout,
		&i.BlockType,
		&i.Variant,
		&i.Properties,
	)
	return i, err
}

const deleteBlock = `-- name: DeleteBlock :exec
DELETE FROM blocks
WHERE id = $1
`

func (q *Queries) DeleteBlock(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBlock, id)
	return err
}

const deleteBlocksByPageID = `-- name: DeleteBlocksByPageID :exec
DELETE FROM blocks
WHERE page_id = $1
`

func (q *Queries) DeleteBlocksByPageID(ctx context.Context, pageID int32) error {
	_, err := q.db.Exec(ctx, deleteBlocksByPageID, pageID)
	return err
}

const getActiveBlocksByPageID = `-- name: GetActiveBlocksByPageID :many
SELECT id, page_id, user_id, block_order, is_active, created_at, updated_at, title, description, layout, block_type, variant, properties FROM blocks
WHERE page_id = $1 AND is_active = true
ORDER BY block_order ASC NULLS LAST, created_at ASC
`

func (q *Queries) GetActiveBlocksByPageID(ctx context.Context, pageID int32) ([]Block, error) {
	rows, err := q.db.Query(ctx, getActiveBlocksByPageID, pageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Block{}
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.PageID,
			&i.UserID,
			&i.BlockOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Description,
			&i.Layout,
			&i.BlockType,
			&i.Variant,
			&i.Properties,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockByID = `-- name: GetBlockByID :one
SELECT id, page_id, user_id, block_order, is_active, created_at, updated_at, title, description, layout, block_type, variant, properties FROM blocks
WHERE id = $1
`

func (q *Queries) GetBlockByID(ctx context.Context, id int32) (Block, error) {
	row := q.db.QueryRow(ctx, getBlockByID, id)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.UserID,
		&i.BlockOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Description,
		&i.Layout,
		&i.BlockType,
		&i.Variant,
		&i.Properties,
	)
	return i, err
}

const getBlocksByPageID = `-- name: GetBlocksByPageID :many
SELECT id, page_id, user_id, block_order, is_active, created_at, updated_at, title, description, layout, block_type, variant, properties FROM blocks
WHERE page_id = $1
ORDER BY block_order ASC NULLS LAST, created_at ASC
`

func (q *Queries) GetBlocksByPageID(ctx context.Context, pageID int32) ([]Block, error) {
	rows, err := q.db.Query(ctx, getBlocksByPageID, pageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Block{}
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.PageID,
			&i.UserID,
			&i.BlockOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Description,
			&i.Layout,
			&i.BlockType,
			&i.Variant,
			&i.Properties,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlocksByPageIDAndType = `-- name: GetBlocksByPageIDAndType :many
SELECT id, page_id, user_id, block_order, is_active, created_at, updated_at, title, description, layout, block_type, variant, properties FROM blocks
WHERE page_id = $1 AND block_type = $2
ORDER BY block_order ASC NULLS LAST, created_at ASC
`

type GetBlocksByPageIDAndTypeParams struct {
	PageID    int32       `json:"page_id"`
	BlockType pgtype.Text `json:"block_type"`
}

func (q *Queries) GetBlocksByPageIDAndType(ctx context.Context, arg GetBlocksByPageIDAndTypeParams) ([]Block, error) {
	rows, err := q.db.Query(ctx, getBlocksByPageIDAndType, arg.PageID, arg.BlockType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Block{}
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.PageID,
			&i.UserID,
			&i.BlockOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Description,
			&i.Layout,
			&i.BlockType,
			&i.Variant,
			&i.Properties,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlocksByUserID = `-- name: GetBlocksByUserID :many
SELECT id, page_id, user_id, block_order, is_active, created_at, updated_at, title, description, layout, block_type, variant, properties FROM blocks
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetBlocksByUserID(ctx context.Context, userID int32) ([]Block, error) {
	rows, err := q.db.Query(ctx, getBlocksByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Block{}
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.PageID,
			&i.UserID,
			&i.BlockOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Description,
			&i.Layout,
			&i.BlockType,
			&i.Variant,
			&i.Properties,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reorderBlocks = `-- name: ReorderBlocks :exec
UPDATE blocks
SET block_order = block_order + $3, updated_at = NOW()
WHERE page_id = $1 AND block_order >= $2
`

type ReorderBlocksParams struct {
	PageID       int32       `json:"page_id"`
	BlockOrder   pgtype.Int4 `json:"block_order"`
	BlockOrder_2 pgtype.Int4 `json:"block_order_2"`
}

func (q *Queries) ReorderBlocks(ctx context.Context, arg ReorderBlocksParams) error {
	_, err := q.db.Exec(ctx, reorderBlocks, arg.PageID, arg.BlockOrder, arg.BlockOrder_2)
	return err
}

const updateBlock = `-- name: UpdateBlock :one
UPDATE blocks
SET
    block_order = COALESCE($1, block_order),
    is_active = COALESCE($2, is_active),
    title = COALESCE($3, title),
    description = COALESCE($4, description),
    layout = COALESCE($5, layout),
    block_type = COALESCE($6, block_type),
    variant = COALESCE($7, variant),
    properties = COALESCE($8, properties),
    updated_at = NOW()
WHERE id = $9
RETURNING id, page_id, user_id, block_order, is_active, created_at, updated_at, title, description, layout, block_type, variant, properties
`

type UpdateBlockParams struct {
	Order       pgtype.Int4 `json:"order"`
	IsActive    pgtype.Bool `json:"is_active"`
	Title       pgtype.Text `json:"title"`
	Description pgtype.Text `json:"description"`
	Layout      pgtype.Text `json:"layout"`
	BlockType   pgtype.Text `json:"block_type"`
	Variant     pgtype.Text `json:"variant"`
	Properties  []byte      `json:"properties"`
	ID          int32       `json:"id"`
}

func (q *Queries) UpdateBlock(ctx context.Context, arg UpdateBlockParams) (Block, error) {
	row := q.db.QueryRow(ctx, updateBlock,
		arg.Order,
		arg.IsActive,
		arg.Title,
		arg.Description,
		arg.Layout,
		arg.BlockType,
		arg.Variant,
		arg.Properties,
		arg.ID,
	)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.UserID,
		&i.BlockOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Description,
		&i.Layout,
		&i.BlockType,
		&i.Variant,
		&i.Properties,
	)
	return i, err
}

const updateBlockOrder = `-- name: UpdateBlockOrder :exec
UPDATE blocks
SET block_order = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateBlockOrderParams struct {
	ID         int32       `json:"id"`
	BlockOrder pgtype.Int4 `json:"block_order"`
}

func (q *Queries) UpdateBlockOrder(ctx context.Context, arg UpdateBlockOrderParams) error {
	_, err := q.db.Exec(ctx, updateBlockOrder, arg.ID, arg.BlockOrder)
	return err
}
