// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vault_note_items.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addNoteAttachment = `-- name: AddNoteAttachment :one
INSERT INTO vault_note_attachments (
    note_item_id,
    filename,
    file_path,
    file_size,
    mime_type
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, note_item_id, filename, file_path, file_size, mime_type, created_at
`

type AddNoteAttachmentParams struct {
	NoteItemID int32       `json:"note_item_id"`
	Filename   string      `json:"filename"`
	FilePath   string      `json:"file_path"`
	FileSize   int32       `json:"file_size"`
	MimeType   pgtype.Text `json:"mime_type"`
}

// Note Attachments queries
func (q *Queries) AddNoteAttachment(ctx context.Context, arg AddNoteAttachmentParams) (VaultNoteAttachment, error) {
	row := q.db.QueryRow(ctx, addNoteAttachment,
		arg.NoteItemID,
		arg.Filename,
		arg.FilePath,
		arg.FileSize,
		arg.MimeType,
	)
	var i VaultNoteAttachment
	err := row.Scan(
		&i.ID,
		&i.NoteItemID,
		&i.Filename,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const createNoteItem = `-- name: CreateNoteItem :one
INSERT INTO vault_note_items (
    vault_id,
    user_id,
    title,
    note,
    is_favorite
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, vault_id, user_id, title, note, is_favorite, created_at, updated_at, last_used_at
`

type CreateNoteItemParams struct {
	VaultID    int32  `json:"vault_id"`
	UserID     int32  `json:"user_id"`
	Title      string `json:"title"`
	Note       string `json:"note"`
	IsFavorite bool   `json:"is_favorite"`
}

func (q *Queries) CreateNoteItem(ctx context.Context, arg CreateNoteItemParams) (VaultNoteItem, error) {
	row := q.db.QueryRow(ctx, createNoteItem,
		arg.VaultID,
		arg.UserID,
		arg.Title,
		arg.Note,
		arg.IsFavorite,
	)
	var i VaultNoteItem
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.UserID,
		&i.Title,
		&i.Note,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const deleteAllNoteAttachments = `-- name: DeleteAllNoteAttachments :exec
DELETE FROM vault_note_attachments
WHERE note_item_id = $1
`

func (q *Queries) DeleteAllNoteAttachments(ctx context.Context, noteItemID int32) error {
	_, err := q.db.Exec(ctx, deleteAllNoteAttachments, noteItemID)
	return err
}

const deleteNoteAttachment = `-- name: DeleteNoteAttachment :exec
DELETE FROM vault_note_attachments
WHERE id = $1 AND note_item_id = $2
`

type DeleteNoteAttachmentParams struct {
	ID         int32 `json:"id"`
	NoteItemID int32 `json:"note_item_id"`
}

func (q *Queries) DeleteNoteAttachment(ctx context.Context, arg DeleteNoteAttachmentParams) error {
	_, err := q.db.Exec(ctx, deleteNoteAttachment, arg.ID, arg.NoteItemID)
	return err
}

const deleteNoteItem = `-- name: DeleteNoteItem :exec
DELETE FROM vault_note_items
WHERE id = $1 AND user_id = $2
`

type DeleteNoteItemParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteNoteItem(ctx context.Context, arg DeleteNoteItemParams) error {
	_, err := q.db.Exec(ctx, deleteNoteItem, arg.ID, arg.UserID)
	return err
}

const getNoteAttachmentByID = `-- name: GetNoteAttachmentByID :one
SELECT id, note_item_id, filename, file_path, file_size, mime_type, created_at FROM vault_note_attachments
WHERE id = $1 AND note_item_id = $2
`

type GetNoteAttachmentByIDParams struct {
	ID         int32 `json:"id"`
	NoteItemID int32 `json:"note_item_id"`
}

func (q *Queries) GetNoteAttachmentByID(ctx context.Context, arg GetNoteAttachmentByIDParams) (VaultNoteAttachment, error) {
	row := q.db.QueryRow(ctx, getNoteAttachmentByID, arg.ID, arg.NoteItemID)
	var i VaultNoteAttachment
	err := row.Scan(
		&i.ID,
		&i.NoteItemID,
		&i.Filename,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.CreatedAt,
	)
	return i, err
}

const getNoteAttachments = `-- name: GetNoteAttachments :many
SELECT id, note_item_id, filename, file_path, file_size, mime_type, created_at FROM vault_note_attachments
WHERE note_item_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetNoteAttachments(ctx context.Context, noteItemID int32) ([]VaultNoteAttachment, error) {
	rows, err := q.db.Query(ctx, getNoteAttachments, noteItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultNoteAttachment{}
	for rows.Next() {
		var i VaultNoteAttachment
		if err := rows.Scan(
			&i.ID,
			&i.NoteItemID,
			&i.Filename,
			&i.FilePath,
			&i.FileSize,
			&i.MimeType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNoteItemByID = `-- name: GetNoteItemByID :one
SELECT id, vault_id, user_id, title, note, is_favorite, created_at, updated_at, last_used_at FROM vault_note_items
WHERE id = $1 AND user_id = $2
`

type GetNoteItemByIDParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetNoteItemByID(ctx context.Context, arg GetNoteItemByIDParams) (VaultNoteItem, error) {
	row := q.db.QueryRow(ctx, getNoteItemByID, arg.ID, arg.UserID)
	var i VaultNoteItem
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.UserID,
		&i.Title,
		&i.Note,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getUserNoteItems = `-- name: GetUserNoteItems :many
SELECT id, vault_id, user_id, title, note, is_favorite, created_at, updated_at, last_used_at FROM vault_note_items
WHERE user_id = $1
ORDER BY is_favorite DESC, updated_at DESC
`

func (q *Queries) GetUserNoteItems(ctx context.Context, userID int32) ([]VaultNoteItem, error) {
	rows, err := q.db.Query(ctx, getUserNoteItems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultNoteItem{}
	for rows.Next() {
		var i VaultNoteItem
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.UserID,
			&i.Title,
			&i.Note,
			&i.IsFavorite,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVaultNoteItems = `-- name: GetVaultNoteItems :many
SELECT id, vault_id, user_id, title, note, is_favorite, created_at, updated_at, last_used_at FROM vault_note_items
WHERE vault_id = $1 AND user_id = $2
ORDER BY is_favorite DESC, updated_at DESC
`

type GetVaultNoteItemsParams struct {
	VaultID int32 `json:"vault_id"`
	UserID  int32 `json:"user_id"`
}

func (q *Queries) GetVaultNoteItems(ctx context.Context, arg GetVaultNoteItemsParams) ([]VaultNoteItem, error) {
	rows, err := q.db.Query(ctx, getVaultNoteItems, arg.VaultID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultNoteItem{}
	for rows.Next() {
		var i VaultNoteItem
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.UserID,
			&i.Title,
			&i.Note,
			&i.IsFavorite,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchNoteItems = `-- name: SearchNoteItems :many
SELECT id, vault_id, user_id, title, note, is_favorite, created_at, updated_at, last_used_at FROM vault_note_items
WHERE user_id = $1 AND (
    title ILIKE '%' || $2 || '%' OR
    note ILIKE '%' || $2 || '%'
)
ORDER BY is_favorite DESC, updated_at DESC
`

type SearchNoteItemsParams struct {
	UserID  int32       `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
}

func (q *Queries) SearchNoteItems(ctx context.Context, arg SearchNoteItemsParams) ([]VaultNoteItem, error) {
	rows, err := q.db.Query(ctx, searchNoteItems, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultNoteItem{}
	for rows.Next() {
		var i VaultNoteItem
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.UserID,
			&i.Title,
			&i.Note,
			&i.IsFavorite,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleNoteItemFavorite = `-- name: ToggleNoteItemFavorite :one
UPDATE vault_note_items
SET 
    is_favorite = NOT is_favorite,
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, vault_id, user_id, title, note, is_favorite, created_at, updated_at, last_used_at
`

type ToggleNoteItemFavoriteParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) ToggleNoteItemFavorite(ctx context.Context, arg ToggleNoteItemFavoriteParams) (VaultNoteItem, error) {
	row := q.db.QueryRow(ctx, toggleNoteItemFavorite, arg.ID, arg.UserID)
	var i VaultNoteItem
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.UserID,
		&i.Title,
		&i.Note,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const updateNoteItem = `-- name: UpdateNoteItem :one
UPDATE vault_note_items
SET 
    title = $2,
    note = $3,
    is_favorite = $4,
    updated_at = NOW()
WHERE id = $1 AND user_id = $5
RETURNING id, vault_id, user_id, title, note, is_favorite, created_at, updated_at, last_used_at
`

type UpdateNoteItemParams struct {
	ID         int32  `json:"id"`
	Title      string `json:"title"`
	Note       string `json:"note"`
	IsFavorite bool   `json:"is_favorite"`
	UserID     int32  `json:"user_id"`
}

func (q *Queries) UpdateNoteItem(ctx context.Context, arg UpdateNoteItemParams) (VaultNoteItem, error) {
	row := q.db.QueryRow(ctx, updateNoteItem,
		arg.ID,
		arg.Title,
		arg.Note,
		arg.IsFavorite,
		arg.UserID,
	)
	var i VaultNoteItem
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.UserID,
		&i.Title,
		&i.Note,
		&i.IsFavorite,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const updateNoteItemLastUsed = `-- name: UpdateNoteItemLastUsed :exec
UPDATE vault_note_items
SET last_used_at = NOW()
WHERE id = $1 AND user_id = $2
`

type UpdateNoteItemLastUsedParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) UpdateNoteItemLastUsed(ctx context.Context, arg UpdateNoteItemLastUsedParams) error {
	_, err := q.db.Exec(ctx, updateNoteItemLastUsed, arg.ID, arg.UserID)
	return err
}
