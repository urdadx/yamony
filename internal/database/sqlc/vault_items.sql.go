// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vault_items.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVaultItems = `-- name: CountVaultItems :one
SELECT COUNT(*) FROM vault_items
WHERE vault_id = $1
`

func (q *Queries) CountVaultItems(ctx context.Context, vaultID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countVaultItems, vaultID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVaultItem = `-- name: CreateVaultItem :one
INSERT INTO vault_items (
    id,
    vault_id,
    item_type,
    encrypted_blob,
    iv,
    tag,
    meta,
    version
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, vault_id, item_type, encrypted_blob, iv, tag, meta, version, created_at, updated_at
`

type CreateVaultItemParams struct {
	ID            pgtype.UUID `json:"id"`
	VaultID       int32       `json:"vault_id"`
	ItemType      string      `json:"item_type"`
	EncryptedBlob []byte      `json:"encrypted_blob"`
	Iv            []byte      `json:"iv"`
	Tag           []byte      `json:"tag"`
	Meta          []byte      `json:"meta"`
	Version       int32       `json:"version"`
}

func (q *Queries) CreateVaultItem(ctx context.Context, arg CreateVaultItemParams) (VaultItem, error) {
	row := q.db.QueryRow(ctx, createVaultItem,
		arg.ID,
		arg.VaultID,
		arg.ItemType,
		arg.EncryptedBlob,
		arg.Iv,
		arg.Tag,
		arg.Meta,
		arg.Version,
	)
	var i VaultItem
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.ItemType,
		&i.EncryptedBlob,
		&i.Iv,
		&i.Tag,
		&i.Meta,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVaultItem = `-- name: DeleteVaultItem :exec
DELETE FROM vault_items
WHERE id = $1
`

func (q *Queries) DeleteVaultItem(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteVaultItem, id)
	return err
}

const getVaultItemByID = `-- name: GetVaultItemByID :one
SELECT id, vault_id, item_type, encrypted_blob, iv, tag, meta, version, created_at, updated_at FROM vault_items
WHERE id = $1
`

func (q *Queries) GetVaultItemByID(ctx context.Context, id pgtype.UUID) (VaultItem, error) {
	row := q.db.QueryRow(ctx, getVaultItemByID, id)
	var i VaultItem
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.ItemType,
		&i.EncryptedBlob,
		&i.Iv,
		&i.Tag,
		&i.Meta,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVaultItemsByIDs = `-- name: GetVaultItemsByIDs :many
SELECT id, vault_id, item_type, encrypted_blob, iv, tag, meta, version, created_at, updated_at FROM vault_items
WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetVaultItemsByIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]VaultItem, error) {
	rows, err := q.db.Query(ctx, getVaultItemsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultItem{}
	for rows.Next() {
		var i VaultItem
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.ItemType,
			&i.EncryptedBlob,
			&i.Iv,
			&i.Tag,
			&i.Meta,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVaultItemsByVaultID = `-- name: GetVaultItemsByVaultID :many
SELECT id, vault_id, item_type, encrypted_blob, iv, tag, meta, version, created_at, updated_at FROM vault_items
WHERE vault_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetVaultItemsByVaultID(ctx context.Context, vaultID int32) ([]VaultItem, error) {
	rows, err := q.db.Query(ctx, getVaultItemsByVaultID, vaultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultItem{}
	for rows.Next() {
		var i VaultItem
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.ItemType,
			&i.EncryptedBlob,
			&i.Iv,
			&i.Tag,
			&i.Meta,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVaultItemsByVaultIDAndType = `-- name: GetVaultItemsByVaultIDAndType :many
SELECT id, vault_id, item_type, encrypted_blob, iv, tag, meta, version, created_at, updated_at FROM vault_items
WHERE vault_id = $1 AND item_type = $2
ORDER BY created_at DESC
`

type GetVaultItemsByVaultIDAndTypeParams struct {
	VaultID  int32  `json:"vault_id"`
	ItemType string `json:"item_type"`
}

func (q *Queries) GetVaultItemsByVaultIDAndType(ctx context.Context, arg GetVaultItemsByVaultIDAndTypeParams) ([]VaultItem, error) {
	rows, err := q.db.Query(ctx, getVaultItemsByVaultIDAndType, arg.VaultID, arg.ItemType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultItem{}
	for rows.Next() {
		var i VaultItem
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.ItemType,
			&i.EncryptedBlob,
			&i.Iv,
			&i.Tag,
			&i.Meta,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVaultItemsByMeta = `-- name: SearchVaultItemsByMeta :many
SELECT id, vault_id, item_type, encrypted_blob, iv, tag, meta, version, created_at, updated_at FROM vault_items
WHERE vault_id = $1 
  AND meta @> $2::jsonb
ORDER BY created_at DESC
LIMIT $3
`

type SearchVaultItemsByMetaParams struct {
	VaultID int32  `json:"vault_id"`
	Column2 []byte `json:"column_2"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) SearchVaultItemsByMeta(ctx context.Context, arg SearchVaultItemsByMetaParams) ([]VaultItem, error) {
	rows, err := q.db.Query(ctx, searchVaultItemsByMeta, arg.VaultID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VaultItem{}
	for rows.Next() {
		var i VaultItem
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.ItemType,
			&i.EncryptedBlob,
			&i.Iv,
			&i.Tag,
			&i.Meta,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVaultItem = `-- name: UpdateVaultItem :one
UPDATE vault_items
SET 
    encrypted_blob = $2,
    iv = $3,
    tag = $4,
    meta = $5,
    version = $6,
    updated_at = NOW()
WHERE id = $1
RETURNING id, vault_id, item_type, encrypted_blob, iv, tag, meta, version, created_at, updated_at
`

type UpdateVaultItemParams struct {
	ID            pgtype.UUID `json:"id"`
	EncryptedBlob []byte      `json:"encrypted_blob"`
	Iv            []byte      `json:"iv"`
	Tag           []byte      `json:"tag"`
	Meta          []byte      `json:"meta"`
	Version       int32       `json:"version"`
}

func (q *Queries) UpdateVaultItem(ctx context.Context, arg UpdateVaultItemParams) (VaultItem, error) {
	row := q.db.QueryRow(ctx, updateVaultItem,
		arg.ID,
		arg.EncryptedBlob,
		arg.Iv,
		arg.Tag,
		arg.Meta,
		arg.Version,
	)
	var i VaultItem
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.ItemType,
		&i.EncryptedBlob,
		&i.Iv,
		&i.Tag,
		&i.Meta,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
