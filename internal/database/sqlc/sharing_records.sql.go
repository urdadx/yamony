// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sharing_records.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptSharingRecord = `-- name: AcceptSharingRecord :one
UPDATE sharing_records
SET status = 'accepted', accepted_at = NOW()
WHERE id = $1 AND status = 'pending'
RETURNING id, vault_id, item_id, sender_user_id, recipient_user_id, wrapped_key, wrap_iv, wrap_tag, status, created_at, accepted_at
`

func (q *Queries) AcceptSharingRecord(ctx context.Context, id pgtype.UUID) (SharingRecord, error) {
	row := q.db.QueryRow(ctx, acceptSharingRecord, id)
	var i SharingRecord
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.ItemID,
		&i.SenderUserID,
		&i.RecipientUserID,
		&i.WrappedKey,
		&i.WrapIv,
		&i.WrapTag,
		&i.Status,
		&i.CreatedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const checkUserVaultAccess = `-- name: CheckUserVaultAccess :one
SELECT 
    CASE 
        WHEN v.user_id = $2 THEN 'owner'::TEXT
        WHEN sr.recipient_user_id = $2 AND sr.status = 'accepted' THEN 'shared'::TEXT
        ELSE NULL
    END as access_level
FROM vaults v
LEFT JOIN sharing_records sr ON v.id = sr.vault_id AND sr.recipient_user_id = $2
WHERE v.id = $1
LIMIT 1
`

type CheckUserVaultAccessParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) CheckUserVaultAccess(ctx context.Context, arg CheckUserVaultAccessParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, checkUserVaultAccess, arg.ID, arg.UserID)
	var access_level interface{}
	err := row.Scan(&access_level)
	return access_level, err
}

const createSharingRecord = `-- name: CreateSharingRecord :one
INSERT INTO sharing_records (
    vault_id,
    item_id,
    sender_user_id,
    recipient_user_id,
    wrapped_key,
    wrap_iv,
    wrap_tag,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, vault_id, item_id, sender_user_id, recipient_user_id, wrapped_key, wrap_iv, wrap_tag, status, created_at, accepted_at
`

type CreateSharingRecordParams struct {
	VaultID         int32       `json:"vault_id"`
	ItemID          pgtype.UUID `json:"item_id"`
	SenderUserID    int32       `json:"sender_user_id"`
	RecipientUserID int32       `json:"recipient_user_id"`
	WrappedKey      []byte      `json:"wrapped_key"`
	WrapIv          []byte      `json:"wrap_iv"`
	WrapTag         []byte      `json:"wrap_tag"`
	Status          string      `json:"status"`
}

func (q *Queries) CreateSharingRecord(ctx context.Context, arg CreateSharingRecordParams) (SharingRecord, error) {
	row := q.db.QueryRow(ctx, createSharingRecord,
		arg.VaultID,
		arg.ItemID,
		arg.SenderUserID,
		arg.RecipientUserID,
		arg.WrappedKey,
		arg.WrapIv,
		arg.WrapTag,
		arg.Status,
	)
	var i SharingRecord
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.ItemID,
		&i.SenderUserID,
		&i.RecipientUserID,
		&i.WrappedKey,
		&i.WrapIv,
		&i.WrapTag,
		&i.Status,
		&i.CreatedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const getPendingSharingRecordsByRecipientID = `-- name: GetPendingSharingRecordsByRecipientID :many
SELECT id, vault_id, item_id, sender_user_id, recipient_user_id, wrapped_key, wrap_iv, wrap_tag, status, created_at, accepted_at
FROM sharing_records
WHERE recipient_user_id = $1 AND status = 'pending'
ORDER BY created_at DESC
`

func (q *Queries) GetPendingSharingRecordsByRecipientID(ctx context.Context, recipientUserID int32) ([]SharingRecord, error) {
	rows, err := q.db.Query(ctx, getPendingSharingRecordsByRecipientID, recipientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharingRecord{}
	for rows.Next() {
		var i SharingRecord
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.ItemID,
			&i.SenderUserID,
			&i.RecipientUserID,
			&i.WrappedKey,
			&i.WrapIv,
			&i.WrapTag,
			&i.Status,
			&i.CreatedAt,
			&i.AcceptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedVaultsForUser = `-- name: GetSharedVaultsForUser :many
SELECT DISTINCT v.id, v.user_id, v.name, v.created_at, v.updated_at
FROM vaults v
INNER JOIN sharing_records sr ON v.id = sr.vault_id
WHERE sr.recipient_user_id = $1 AND sr.status = 'accepted'
ORDER BY v.created_at DESC
`

type GetSharedVaultsForUserRow struct {
	ID        int32            `json:"id"`
	UserID    int32            `json:"user_id"`
	Name      string           `json:"name"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetSharedVaultsForUser(ctx context.Context, recipientUserID int32) ([]GetSharedVaultsForUserRow, error) {
	rows, err := q.db.Query(ctx, getSharedVaultsForUser, recipientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSharedVaultsForUserRow{}
	for rows.Next() {
		var i GetSharedVaultsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharingRecordByID = `-- name: GetSharingRecordByID :one
SELECT id, vault_id, item_id, sender_user_id, recipient_user_id, wrapped_key, wrap_iv, wrap_tag, status, created_at, accepted_at
FROM sharing_records
WHERE id = $1
`

func (q *Queries) GetSharingRecordByID(ctx context.Context, id pgtype.UUID) (SharingRecord, error) {
	row := q.db.QueryRow(ctx, getSharingRecordByID, id)
	var i SharingRecord
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.ItemID,
		&i.SenderUserID,
		&i.RecipientUserID,
		&i.WrappedKey,
		&i.WrapIv,
		&i.WrapTag,
		&i.Status,
		&i.CreatedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const getSharingRecordByVaultAndRecipient = `-- name: GetSharingRecordByVaultAndRecipient :one
SELECT id, vault_id, item_id, sender_user_id, recipient_user_id, wrapped_key, wrap_iv, wrap_tag, status, created_at, accepted_at
FROM sharing_records
WHERE vault_id = $1 AND recipient_user_id = $2 AND status = 'accepted'
`

type GetSharingRecordByVaultAndRecipientParams struct {
	VaultID         int32 `json:"vault_id"`
	RecipientUserID int32 `json:"recipient_user_id"`
}

func (q *Queries) GetSharingRecordByVaultAndRecipient(ctx context.Context, arg GetSharingRecordByVaultAndRecipientParams) (SharingRecord, error) {
	row := q.db.QueryRow(ctx, getSharingRecordByVaultAndRecipient, arg.VaultID, arg.RecipientUserID)
	var i SharingRecord
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.ItemID,
		&i.SenderUserID,
		&i.RecipientUserID,
		&i.WrappedKey,
		&i.WrapIv,
		&i.WrapTag,
		&i.Status,
		&i.CreatedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const getSharingRecordsByRecipientID = `-- name: GetSharingRecordsByRecipientID :many
SELECT id, vault_id, item_id, sender_user_id, recipient_user_id, wrapped_key, wrap_iv, wrap_tag, status, created_at, accepted_at
FROM sharing_records
WHERE recipient_user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetSharingRecordsByRecipientID(ctx context.Context, recipientUserID int32) ([]SharingRecord, error) {
	rows, err := q.db.Query(ctx, getSharingRecordsByRecipientID, recipientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharingRecord{}
	for rows.Next() {
		var i SharingRecord
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.ItemID,
			&i.SenderUserID,
			&i.RecipientUserID,
			&i.WrappedKey,
			&i.WrapIv,
			&i.WrapTag,
			&i.Status,
			&i.CreatedAt,
			&i.AcceptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharingRecordsByVaultID = `-- name: GetSharingRecordsByVaultID :many
SELECT id, vault_id, item_id, sender_user_id, recipient_user_id, wrapped_key, wrap_iv, wrap_tag, status, created_at, accepted_at
FROM sharing_records
WHERE vault_id = $1 AND status = 'accepted'
ORDER BY created_at DESC
`

func (q *Queries) GetSharingRecordsByVaultID(ctx context.Context, vaultID int32) ([]SharingRecord, error) {
	rows, err := q.db.Query(ctx, getSharingRecordsByVaultID, vaultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SharingRecord{}
	for rows.Next() {
		var i SharingRecord
		if err := rows.Scan(
			&i.ID,
			&i.VaultID,
			&i.ItemID,
			&i.SenderUserID,
			&i.RecipientUserID,
			&i.WrappedKey,
			&i.WrapIv,
			&i.WrapTag,
			&i.Status,
			&i.CreatedAt,
			&i.AcceptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectSharingRecord = `-- name: RejectSharingRecord :one
UPDATE sharing_records
SET status = 'rejected'
WHERE id = $1 AND status = 'pending'
RETURNING id, vault_id, item_id, sender_user_id, recipient_user_id, wrapped_key, wrap_iv, wrap_tag, status, created_at, accepted_at
`

func (q *Queries) RejectSharingRecord(ctx context.Context, id pgtype.UUID) (SharingRecord, error) {
	row := q.db.QueryRow(ctx, rejectSharingRecord, id)
	var i SharingRecord
	err := row.Scan(
		&i.ID,
		&i.VaultID,
		&i.ItemID,
		&i.SenderUserID,
		&i.RecipientUserID,
		&i.WrappedKey,
		&i.WrapIv,
		&i.WrapTag,
		&i.Status,
		&i.CreatedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const revokeSharingRecord = `-- name: RevokeSharingRecord :exec
UPDATE sharing_records
SET status = 'revoked'
WHERE id = $1
`

func (q *Queries) RevokeSharingRecord(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeSharingRecord, id)
	return err
}
